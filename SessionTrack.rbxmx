<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX14928AEB684542B4A45E628FE4F43656">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">SessionTrack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX08D5328132874509942F4846E8D5FD90">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Packages</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX611EF9AF2FDC4BDCAC0AEA5AEA48BDEA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Signal</string>
					<string name="ScriptGuid">{05384696-FB6A-414D-9EAF-4D79D606D476}</string>
					<ProtectedString name="Source"><![CDATA[local REQUIRED_MODULE = require(script.Parent._Index["sleitnick_signal@2.0.1"]["signal"])
export type Connection = REQUIRED_MODULE.Connection 
export type Signal<T...> = REQUIRED_MODULE.Signal<T...>
return REQUIRED_MODULE
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX576C511704F642D7992401C3E41AD7C5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Voyager</string>
					<string name="ScriptGuid">{2F26A823-A459-4AAC-A907-9F69ED321C23}</string>
					<ProtectedString name="Source"><![CDATA[local REQUIRED_MODULE = require(script.Parent._Index["blackferrari2_voyager@0.1.0"]["voyager"])
export type RatelimitInformation = REQUIRED_MODULE.RatelimitInformation 
export type RatelimitedInformation = REQUIRED_MODULE.RatelimitedInformation 
export type RequestStatus = REQUIRED_MODULE.RequestStatus 
return REQUIRED_MODULE
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX484AE9C33AF2490D8604323FE6E7DF9C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_Index</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX030C5C9F919E4F4BB63AEE72EAE05D4A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">blackferrari2_voyager@0.1.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXAE5381C51A3A4CFCA551207EA5367B32">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">voyager</string>
							<string name="ScriptGuid">{5D3FD4CF-5FBB-4B08-9CE2-F2EBBA8DDBD1}</string>
							<ProtectedString name="Source"><![CDATA[local Webhook = {}
Webhook.__index = Webhook

local Message = require(script.Message)
local EditedMessage = require(script.EditedMessage)
local ThreadMessage = require(script.ThreadMessage)
local EditedThreadMessage = require(script.EditedThreadMessage)
local OptionalExecuteInfo = require(script.OptionalExecuteInfo)

type RatelimitInfo = {
	XRatelimitLimit : number?,
	XRatelimitRemaining : number?,
	XRatelimitReset : string?,
	XRatelimitResetAfter : number?,
	XRatelimitBucket : string?
}

export type RatelimitInformation = {
	limit : number,
	remaining : number,
	reset : DateTime,
	resetAfter : number, -- In seconds.
	resetAfterSafe : number,
	bucket : string,
}

export type RatelimitedInformation = {
	scope : string,
	retryAfter : number, -- In milliseconds since proxy uses v6 of the Discord API.
	retryAfterSafe : number
}

export type RequestStatus = {
	success : boolean,
	statusCode : number,
	statusMessage : string
}

function Webhook.new(id : string, token : string, customProxyUrl : string?)
	local self = setmetatable({}, Webhook)

	self.id = id
	self.token = token
	self.baseUrl = (customProxyUrl or "https://webhook.lewisakura.moe") .. "/api/webhooks/" .. self.id .. "/" .. self.token
	self.ratelimitInfo = {} :: RatelimitInfo

	return self
end

function Webhook.fromUrl(webhookUrl: string, customProxyUrl : string?)
	local self = setmetatable({}, Webhook)
	local webhookId, webhookToken = string.match(webhookUrl, "^https://discord.com/api/webhooks/(%d+)/([%w%p]+)$")
	
	if (not webhookId) or (not webhookToken) then
		error("Invalid webhook url.")
	end
	
	self.id = webhookId
	self.token = webhookToken
	self.baseUrl = (customProxyUrl or "https://webhook.lewisakura.moe") .. "/api/webhooks/" .. self.id .. "/" .. self.token
	self.ratelimitInfo = {} :: RatelimitInfo

	return self
end

function Webhook:_validateExecuteRequest(content : string?, embeds : {}?, optionalExecuteInfo) : (boolean, string?)
	if (not content or content == "") and (not embeds or #embeds == 0) then
		return false, "one of content, embeds are required." 
	end

	if content then
		if string.len(content) > 2000 then 
			return false, "The content must only contain up to 2000 characters." 
		end 
	end

	if optionalExecuteInfo.usernameOverride then
		local restrictedUsernames = {"everyone", "here"}
		local restrictedSubStrings = {"discord", "clyde", "```"}
		local loweredUsername = optionalExecuteInfo.usernameOverride:lower()

		for _, restrictedUsername in restrictedUsernames do	
			if loweredUsername == restrictedUsername then return false, "Username override is a restricted username. \"" .. restrictedUsername .. "\"" end
		end

		for _, restrictedSubString in restrictedSubStrings do	
			if loweredUsername:match(restrictedSubString) then return false, "Username override contains a restricted substring. \"" .. restrictedSubString .. "\"" end
		end

		if string.len(optionalExecuteInfo.usernameOverride) < 1 or string.len(optionalExecuteInfo.usernameOverride) > 80 then
			return false, "Username override must be between 1 and 80 in length." 
		end
	end

	if optionalExecuteInfo.threadId and optionalExecuteInfo.threadName then
		return false, "threadId and threadName cannot be used together."
	end

	if embeds then
		local totalEmbedCharacters = 0
		
		if #embeds > 10 then 
			return false, "A single message must only have up to 10 embeds." 
		end 

		for _, embed in embeds do
			local isEmbedValid, errorMessage = embed:_validate()
			if not isEmbedValid then return false, errorMessage end
			
			totalEmbedCharacters += embed:totalCharacters()
		end

		if totalEmbedCharacters > 6000 then return false, "The combined sum of characters across all embeds attached to a message must only be up to 6000 characters." end
	end

	return true
end

function Webhook:_validateEditMessageRequest(content : string?, embeds : {}?) : (boolean, string?)
	if content then
		if string.len(content) > 2000 then 
			return false, "The content must only contain up to 2000 characters." 
		end 
	end

	if embeds then
		local totalEmbedCharacters = 0

		for _, embed in embeds do
			local isEmbedValid, errorMessage = embed:_validate()
			if not isEmbedValid then return false, errorMessage end

			totalEmbedCharacters += embed:totalCharacters()
		end

		if totalEmbedCharacters > 6000 then return false, "The combined sum of characters across all embeds attached to a message must only be up to 6000 characters." end
	end

	return true
end

function Webhook:_request(url : string, method : string, body : {}?, contentType : string?) : ({}?, RequestStatus, RatelimitInformation | RatelimitedInformation | {})
	local httpService = game:GetService("HttpService")
	
	local response = httpService:RequestAsync({
		Url = url,
		Method = method,
		Headers = {["Content-Type"] = contentType},
		Body = httpService:JSONEncode(body)
	})
	local responseHeaders : {} = response.Headers
	local decodedBody : {} | nil
	local ratelimitInformation : RatelimitInformation | RatelimitedInformation | {} = {}
	local wasRequestQueued : boolean = false
	
	self.ratelimitInfo = {
		XRatelimitLimit = tonumber(responseHeaders["x-ratelimit-limit"]),
		XRatelimitRemaining = tonumber(responseHeaders["x-ratelimit-remaining"]),
		XRatelimitReset = responseHeaders["x-ratelimit-reset"],
		XRatelimitResetAfter = tonumber(responseHeaders["x-ratelimit-reset-after"]),
		XRatelimitBucket = responseHeaders["x-ratelimit-bucket"]
	}
	
	if response.Body ~= "" then
		decodedBody = httpService:JSONDecode(response.Body)
		wasRequestQueued = decodedBody.proxy
	end
	
	if response.Success and not wasRequestQueued then
		ratelimitInformation = {
			limit = tonumber(responseHeaders["x-ratelimit-limit"]),
			remaining = tonumber(responseHeaders["x-ratelimit-remaining"]),
			reset = DateTime.fromUnixTimestamp(tonumber(responseHeaders["x-ratelimit-reset"])),
			resetAfter = tonumber(responseHeaders["x-ratelimit-reset-after"]), 
			resetAfterSafe = tonumber(responseHeaders["x-ratelimit-reset-after"]) + 1,
			bucket = responseHeaders["x-ratelimit-bucket"]		
		} :: RatelimitInformation
	elseif response.StatusCode == 429 and not wasRequestQueued then	
		if not responseHeaders["via"] then
			-- Cloudflare ratelimit
			
			ratelimitInformation = {
				scope = "global", -- Cloudflare ratelimits count as global.
				retryAfter = tonumber(responseHeaders["retry-after"]),
				retryAfterSafe = responseHeaders["retry-after"] + 1000	
			} :: RatelimitedInformation
		else
			-- Discord ratelimit
			
			ratelimitInformation = {
				scope = responseHeaders["x-ratelimit-scope"],
				retryAfter = tonumber(responseHeaders["retry-after"]),
				retryAfterSafe = responseHeaders["retry-after"] + 1000,
			} :: RatelimitedInformation
		end
	end
	
	local requestStatus : requestStatus = {
		success = response.Success, 
		statusCode = response.StatusCode, 
		statusMessage = response.StatusMessage
	}

	return decodedBody, requestStatus, ratelimitInformation
end

function Webhook:execute(content : string?, embeds : {}?, queue : boolean, waitForMessage : boolean, optionalExecuteInfo) : ({}?, RequestStatus, RatelimitInformation | RatelimitedInformation | {})
	local executeInfo = optionalExecuteInfo or OptionalExecuteInfo.new()
	local isRequestValid, errorMessage = self:_validateExecuteRequest(content, embeds, executeInfo)	
	if not isRequestValid then return error(errorMessage) end
	
	if queue == nil then queue = true end
	if waitForMessage == nil then waitForMessage = false end
	
	local requestUrl = self.baseUrl
	local requestBody = {
		content = content,
		username = executeInfo.usernameOverride,
		avatar_url = executeInfo.avatarOverride,
		tts = executeInfo.tts,
		embeds = embeds,
		flags = executeInfo.messageFlags.value,
		thread_name = executeInfo.threadName
	}
	
	if queue then requestUrl ..= "/queue" end
	requestUrl ..= "?wait=" .. tostring(waitForMessage)
	if executeInfo.threadId then requestUrl ..= "&thread_id=" .. executeInfo.threadId end

	local responseBody, requestStatus, requestRatelimitInfo = self:_request(requestUrl, "POST", requestBody, "application/json")

	if not queue and waitForMessage and requestStatus.success then
		if not executeInfo.threadId then 
			return Message.new(responseBody), requestStatus, requestRatelimitInfo
		else
			return ThreadMessage.new(responseBody), requestStatus, requestRatelimitInfo
		end
	end
	
	return nil, requestStatus, requestRatelimitInfo
end

function Webhook:editMessage(messageId : string, content : string?, embeds : {}?, threadId : string?) : ({}?, RequestStatus, RatelimitInformation | RatelimitedInformation)
	local isRequestValid, errorMessage = self:_validateEditMessageRequest(content, embeds)
	if not isRequestValid then return error(errorMessage) end
	
	local requestUrl = self.baseUrl .. "/messages/" .. messageId
	local requestBody = {
		content = content,
		embeds = embeds
	}

	if threadId then requestUrl ..= "?thread_id=" .. threadId end
	
	local responseBody, requestStatus, requestRatelimitInfo = self:_request(requestUrl, "PATCH", requestBody, "application/json")
	
	if not requestStatus.success then return nil, requestStatus end

	if not threadId then
		return EditedMessage.new(responseBody), requestStatus, requestRatelimitInfo
	else
		return EditedThreadMessage.new(responseBody), requestStatus, requestRatelimitInfo
	end
end

function Webhook:deleteMessage(messageId : string, threadId : string?) : (RequestStatus, RatelimitInformation | RatelimitedInformation)
	local requestUrl = self.baseUrl .. "/messages/" .. messageId

	if threadId then requestUrl ..= "?thread_id=" .. threadId end	
	
	local _, requestStatus, requestRatelimitInfo = self:_request(requestUrl, "DELETE")
	
	return requestStatus, requestRatelimitInfo
end

return Webhook]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX513942074C604BF4B938CB3FAEAABD9E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Author</string>
								<string name="ScriptGuid">{F8EC08C6-786A-4A4A-AE39-B6764C13D53E}</string>
								<ProtectedString name="Source"><![CDATA[local Author = {}
Author.__index = Author

function Author.new(data)
	local self = setmetatable({}, Author)
	
	self.id = data.id
	self.username = data.username
	self.avatar = data.avatar
	self.bot = data.bot or false
	
	return self
end

function Author:getAvatarUrl(size : number?, imageFormat : string?) : string?
	if not self.avatar then return end
	if imageFormat then 
		if imageFormat ~= ".jpeg" and imageFormat ~= ".png" and imageFormat ~= ".webp" and imageFormat ~= ".gif" then return error("Unsupported image format given.") end 
	end
	
	if size then
		if size < 16 or size > 4096 then return error("Image size must be between 16 to 4096.") end
		if math.sqrt(size) % 1 ~= 0 then return error("Image size must be any power of two") end
		
		return "https://cdn.discordapp.com/avatars/" .. self.id .. "/" .. self.avatar .. (imageFormat or ".png") .. "?size=" .. size
	else
		return "https://cdn.discordapp.com/avatars/" .. self.id .. "/" .. self.avatar .. (imageFormat or ".png")
	end
end

function Author:hasAnimatedAvatar() : boolean
	if not self.avatar then return false end
	
	return self.avatar:match("a_") == "a_"
end

return Author]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5AA1C385FB5740A1855B73450111B403">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">EditedMessage</string>
								<string name="ScriptGuid">{34275909-5D71-4759-B849-1A06EACE99E8}</string>
								<ProtectedString name="Source"><![CDATA[local EditedMessage = {}
EditedMessage.__index = EditedMessage

local Message = require(script.Parent.Message)

setmetatable(EditedMessage, Message)

function EditedMessage.new(data)
	local self = setmetatable(Message.new(data), EditedMessage)
	
	self.editedTimestamp = data.edited_timestamp
	self.editedAt = DateTime.fromIsoDate(data.edited_timestamp)
	
	return self
end

return EditedMessage]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4B2E7E4D25D648FB8F0CD0154E9C7D59">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">EditedThreadMessage</string>
								<string name="ScriptGuid">{71BC642D-0B31-4C78-AD93-4408263FF5BA}</string>
								<ProtectedString name="Source"><![CDATA[local EditedThreadMessage = {}
EditedThreadMessage.__index = EditedThreadMessage

local ThreadMessage = require(script.Parent.ThreadMessage)

setmetatable(EditedThreadMessage, ThreadMessage)

function EditedThreadMessage.new(data)
	local self = setmetatable(ThreadMessage.new(data), EditedThreadMessage)
	
	self.editedTimestamp = data.edited_timestamp
	self.editedAt = DateTime.fromIsoDate(data.edited_timestamp)
	
	return self
end

return EditedThreadMessage]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFCBFB7605EBE46D584D2E8F4B7169AC9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Embed</string>
								<string name="ScriptGuid">{5BEE53D2-5F7D-4FB2-B7BB-444C74FEAED3}</string>
								<ProtectedString name="Source"><![CDATA[local Embed = {}
Embed.__index = Embed

function Embed.new(title : string?, description : string?, url : string?)
	local self = setmetatable({}, Embed)
	
	self.title = title
	self.description = description
	self.url = url
	
	self.fields = {}
	
	return self
end

function Embed:_validate() : (boolean, string?)
	if self.title then
		if string.len(self.title) > 256 then return false, "The title of an embed must only contain up to 256 characters." end 
	end
	
	if self.description then
		if string.len(self.description) > 4096 then return false, "The description of an embed must only contain up to 4096 characters." end 
	end
	
	if self.footer then 
		if string.len(self.footer.text) > 2048 then return false, "The text in a footer must only contain up to 2048 characters." end 
		
		if self.footer.icon_url then
			if not self.footer.icon_url:match("https") then return false, "The footer's icon url only supports HTTP(S)." end
		end
	end
	
	if self.image then
		if not self.image.url:match("https") then return false, "The image's url only supports HTTP(S)." end
	end
	
	if self.thumbnail then
		if not self.thumbnail.url:match("https") then return false, "The thumbnail's url only supports HTTP(S)." end	
	end
	
	if self.author then 
		if string.len(self.author.name) > 256 then return false, "The name of an author must only contain up to 256 characters." end
		
		if self.author.icon_url then
			if not self.author.icon_url:match("https") then return false, "The author's icon url only supports HTTP(S)." end
		end
	end
	
	if #self.fields > 25 then return false, "One embed must only have up to 25 fields." end
	
	for _, field in self.fields do
		if string.len(field.name) > 256 then return false, "The name of a field must only contain up to 256 characters." end
		if string.len(field.value) > 1024 then return false, "The value of a field must only contain up to 1024 characters." end			
	end
	
	return true
end

function Embed:setTitle(title : string) : nil	
	self.title = title
end

function Embed:setDescription(description : string) : nil	
	self.description = description
end

function Embed:setUrl(url : string) : nil
	self.url = url
end

function Embed:setTimestamp(customTimestamp : string?) : nil
	if customTimestamp then self.timestamp = customTimestamp return end

	self.timestamp = os.date("!%Y-%m-%dT%H:%M:%S." .. math.round(tick() % 1 * 1000) .. "Z")
end

function Embed:setColor(color3 : Color3) : nil
	self.color = bit32.lshift((color3.R * 255), 16) + bit32.lshift((color3.G * 255), 8) + (color3.B * 255)
end

function Embed:setFooter(text : string, iconUrl : string?) : nil
	self.footer = {
		text = text,
		icon_url = iconUrl
	}
end

function Embed:setImage(url : string) : nil
	self.image = {
		url = url
	}
end

function Embed:setThumbnail(url : string) : nil
	self.thumbnail = {
		url = url
	}
end

function Embed:setAuthor(name : string, url : string?, iconUrl : string?) : nil
	self.author = {
		name = name,
		url = url,
		icon_url = iconUrl
	}
end

function Embed:addField(name : string, value : string, inLine : boolean?) : nil
	table.insert(self.fields, {
		name = name,
		value = value,
		inline = inLine
	})
end

function Embed:totalCharacters() : number
	local total = 0
	
	if self.title then total += string.len(self.title) end
	if self.description then total += string.len(self.description) end
	if self.footer then total += string.len(self.footer.text) end
	if self.author then total += string.len(self.author.name) end
	
	if self.fields then
		for _, field in self.fields do
			total += (string.len(field.name) + string.len(field.value))
		end
	end
	
	return total
end

function Embed:colorToRGB() : {red : number, green : number, blue : number}?
	if not self.color then return end
	
	local r = bit32.band((bit32.rshift(self.color, (8 * 2))), 0xFF)
	local g = bit32.band((bit32.rshift(self.color, (8 * 1))), 0xFF)
	local b = bit32.band((bit32.rshift(self.color, (8 * 0))), 0xFF)
	
	return {
		red = r,
		green = g,
		blue = b
	}
end

return Embed]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX34BC04785ECB4DF3A8561949DDFC452A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Emoji</string>
								<string name="ScriptGuid">{FA3FCE2B-140F-47D1-99E7-BB47D7DD0CEF}</string>
								<ProtectedString name="Source"><![CDATA[local Emoji = {}
Emoji.__index = Emoji

function Emoji.new(data)
	local self = setmetatable({}, Emoji)
	
	self.id = data.id
	self.name = data.name
	self.animated = data.animated or false
	
	return self
end

return Emoji]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0537602518CB4C43B2DE02A1F05E45C3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Message</string>
								<string name="ScriptGuid">{A03D2F8F-5064-4C9D-910F-D371EEDF0968}</string>
								<ProtectedString name="Source"><![CDATA[local Message = {}
Message.__index = Message

local Author = require(script.Parent.Author)
local User = require(script.Parent.User)
local Embed = require(script.Parent.Embed)
local Reaction = require(script.Parent.Reaction)
local MessageFlags = require(script.Parent.MessageFlags)

function Message.new(data)
	local self = setmetatable({}, Message)

	self.id = data.id
	self.messageType = data["type"]
	self.content = data.content
	self.channelId = data.channel_id
	self.author = Author.new(data.author)
	self.embeds = {}
	self.reactions = {}
	self.mentions = {}
	self.mentionRoles = {}
	self.pinned = data.pinned
	self.mentionEveryone = data.mention_everyone
	self.tts = data.tts
	self.timestamp = data.timestamp
	self.createdAt = DateTime.fromIsoDate(data.timestamp)
	self.flags = MessageFlags.fromBitfield(data.flags)
	self.webhookId = data.webhook_id
	self.jumpUrl = "https://discord.com/channels/@me/" .. self.channelId .. "/" .. self.id

	if data.embeds then
		for _, embedData in data.embeds do
			local embed = Embed.new(embedData.title, embedData.description, embedData.url)

			if embedData.color then
				embed.color = embedData.color
			end

			if embedData.timestamp then
				embed:setTimestamp(embedData.timestamp)
			end

			if embedData.footer then
				embed:setFooter(embedData.footer.text, embedData.footer.icon_url) 

				embed.footer.proxy_icon_url = embedData.footer.proxy_icon_url
			end

			if embedData.image then 
				embed:setImage(embedData.image.url)

				embed.image.height = embedData.image.height
				embed.image.width = embedData.image.width
				embed.image.proxy_url = embedData.image.proxy_url
			end

			if embedData.thumbnail then
				embed:setThumbnail(embedData.thumbnail.url)

				embed.thumbnail.height = embedData.thumbnail.height
				embed.thumbnail.width = embedData.thumbnail.width
				embed.thumbnail.proxy_url = embedData.thumbnail.proxy_url
			end

			if embedData.author then 
				embed:setAuthor(embedData.author.name, embedData.author.url, embedData.author.icon_url)

				embed.author.proxy_icon_url = embedData.author.proxy_icon_url
			end	

			if embedData.fields then
				for _, fieldData in embedData.fields do
					embed:addField(fieldData.name, fieldData.value, fieldData.inline)
				end
			end

			table.insert(self.embeds, embed)
		end
	end	

	if data.mentions then
		for _, mentionData in data.mentions do
			table.insert(self.mentions, User.new(mentionData))
		end
	end	

	if data.mention_roles then
		for _, roleId in data.mention_roles do
			table.insert(self.mentionRoles, roleId)
		end
	end	

	if data.reactions then
		for _, reactionData in data.reactions do
			table.insert(self.reactions, Reaction.new(reactionData))
		end
	end

	return self
end

return Message]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE7C83CF5939041C09CEEF0BD58E6DB3D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">MessageFlags</string>
								<string name="ScriptGuid">{C18D0F8A-193C-48C2-AC35-122FD397DE5E}</string>
								<ProtectedString name="Source"><![CDATA[local MessageFlags = {}
MessageFlags.__index = MessageFlags

local BaseFlags = require(script.Parent.bases.BaseFlags)

setmetatable(MessageFlags, BaseFlags)

function MessageFlags.fromFlags(flags : {[number] : number})
	local self = setmetatable(BaseFlags.fromBitfield(0), MessageFlags)
	
	for _, flag in flags do
		self.value = bit32.bor(self.value, flag)
	end

	return self
end

return MessageFlags]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1197CA1D1A1A42C7A70A3305CFDA543A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">OptionalExecuteInfo</string>
								<string name="ScriptGuid">{72EA2FBA-BC1B-4AB9-92A2-1FFB4B580D23}</string>
								<ProtectedString name="Source"><![CDATA[local OptionalExecuteInfo = {}
OptionalExecuteInfo.__index = OptionalExecuteInfo

local MessageFlags = require(script.Parent.MessageFlags)

function OptionalExecuteInfo.new(threadId : string?, tts : boolean?, usernameOverride : string?, avatarOverride : string?, messageFlags : MessageFlags?, threadName : string?)
	local self = setmetatable({}, OptionalExecuteInfo)
	
	self.threadId = threadId
	self.tts = tts or false
	self.usernameOverride = usernameOverride
	self.avatarOverride = avatarOverride
	self.messageFlags = messageFlags or MessageFlags.fromBitfield(0)
	self.threadName = threadName
	
	return self
end

return OptionalExecuteInfo]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE4BB58A0B33849C1B9EF3372F2EBA7E2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PublicUserFlags</string>
								<string name="ScriptGuid">{AA35FF8C-973D-4651-A55E-E71C883663E5}</string>
								<ProtectedString name="Source"><![CDATA[local PublicUserFlags = {}
PublicUserFlags.__index = PublicUserFlags

local BaseFlags = require(script.Parent.bases.BaseFlags)

setmetatable(PublicUserFlags, BaseFlags)

function PublicUserFlags.fromBitfield(value : number)
	local self = setmetatable(BaseFlags.fromBitfield(value), PublicUserFlags)

	return self
end

function PublicUserFlags:getFlags() : {[number] : number}
	local enum = require(script.Parent.utilities.Enum)
	local flags = {}
	
	for _, flag in enum.UserPublicFlags do
		if self:hasFlag(flag) then table.insert(flags, flag) end
	end
	
	return flags
end

return PublicUserFlags]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA0FCAA84B4AD45BE8C5E8004A73C741D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Reaction</string>
								<string name="ScriptGuid">{B70B24D8-A5A6-4DB3-AD31-915A14F9784E}</string>
								<ProtectedString name="Source"><![CDATA[local Reaction = {}
Reaction.__index = Reaction

local Emoji = require(script.Parent.Emoji)

function Reaction.new(data)
	local self = setmetatable({}, Reaction)

	self.emoji = Emoji.new(data.emoji)
	self.me = data.me
	self.count = data.count

	return self
end

return Reaction]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEDFEF873D8FB4C56AAF7227357206F41">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ThreadMessage</string>
								<string name="ScriptGuid">{F57E88B7-5123-423A-82C2-E63E45A37FFE}</string>
								<ProtectedString name="Source"><![CDATA[local ThreadMessage = {}
ThreadMessage.__index = ThreadMessage

local Message = require(script.Parent.Message)

setmetatable(ThreadMessage, Message)

function ThreadMessage.new(data)
	local self = setmetatable(Message.new(data), ThreadMessage)
	
	self.position = data.position
	
	return self
end

return ThreadMessage]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX650B1E535A6A4AF2B8C683B6C35FEF5F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">User</string>
								<string name="ScriptGuid">{BDB00773-E4B9-436F-9FA0-48C4B462266B}</string>
								<ProtectedString name="Source"><![CDATA[local User = {}
User.__index = User

local Author = require(script.Parent.Author)
local PublicUserFlags = require(script.Parent.PublicUserFlags)

setmetatable(User, Author)

function User.new(data)
	local self = setmetatable(Author.new(data), User)
	
	self.globalName = data.global_name
	self.publicFlags = PublicUserFlags.fromBitfield(data.public_flags)
	
	return self
end

return User]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX9A03FABB7717480ABE31529B593A1079">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">bases</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX139A9903113F4483BD23C8DB20B6A1F8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BaseFlags</string>
									<string name="ScriptGuid">{DF34089C-42A5-48A3-977D-F2CFE8DE2E39}</string>
									<ProtectedString name="Source"><![CDATA[local BaseFlags = {}
BaseFlags.__index = BaseFlags

function BaseFlags.fromBitfield(value : number)
	local self = setmetatable({}, BaseFlags)
	
	self.value = value
	
	return self
end

function BaseFlags:hasFlag(flag : number) : boolean
	return bit32.band(self.value, flag) == flag
end

function BaseFlags:setFlag(flag : number, toggle : boolean) : nil
	if toggle then
		self.value = bit32.bor(self.value, flag)
	else
		self.value = bit32.band(self.value, bit32.bnot(flag))
	end
end

return BaseFlags]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXEB0279109D3C462C9FE5A40568C7A565">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">utilities</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX5F970CB799D0463B8BCDC852B4C78931">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Enum</string>
									<string name="ScriptGuid">{CE057838-BE56-4C66-B84D-8A82B7A37AFF}</string>
									<ProtectedString name="Source"><![CDATA[return {
	UserPublicFlags = {
		STAFF = 1,
		PARTNER = 2,
		HYPESQUAD = 4,
		BUG_HUNTER_LEVEL_1 = 8,
		HYPESQUAD_ONLINE_HOUSE_1 = 64,
		HYPESQUAD_ONLINE_HOUSE_2 = 128,
		HYPESQUAD_ONLINE_HOUSE_3 = 256,
		PREMIUM_EARLY_SUPPORTER = 512,
		TEAM_PSEUDO_USER = 1024,
		BUG_HUNTER_LEVEL_2 = 16384,
		VERIFIED_BOT = 65536,
		VERIFIED_DEVELOPER = 131072,
		CERTIFIED_MODERATOR = 262144,
		BOT_HTTP_INTERACTIONS = 524288,
		ACTIVE_DEVELOPER = 4194304		
	},

	MessageFlags = {
		SUPPRESS_EMBEDS = 4
	},

	AvatarImageFormats = {
		JPEG = ".jpeg",
		PNG = ".png",
		WebP = ".webp",
		GIF = ".gif"
	},
	
	RatelimitScopes = {
		USER = "user",
		SHARED = "shared",
		GLOBAL = "global"
	}
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX55478201CFB749108BF1322FB9731503">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">osyrisrblx_t@3.0.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3535927C15B64D87BAF3DE4F7AFD5844">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">t</string>
							<string name="ScriptGuid">{C0603562-839E-4E10-95F6-0E8B6E1174D7}</string>
							<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false, "unexpected non-NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end

	if value % 1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end

		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess, stringErrMsg = t.string(value)
		if not stringSuccess then
			return false, stringErrMsg
		end

		if string.match(value, pattern) == nil then
			return false, string.format("%q failed to match pattern %q", value, pattern)
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success, errMsg = check(args[i])
			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[strictArray] %s", keyErrMsg or "")
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false, string.format("[strictArray] Array size exceeds limit of %d", #valueTypes)
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess, typeErrMsg = typeFn(value[idx])
				if not typeSuccess then
					return false, string.format("[strictArray] Array index #%d - %s", idx, typeErrMsg)
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false, "bad type for union"
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field %q", tostring(key))
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess, instanceErrMsg = t.Instance(value)
			if not instanceSuccess then
				return false, instanceErrMsg or ""
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false, string.format("Cannot process multiple children with the same name %q", name)
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success, errMsg = check(childrenByName[name])
				if not success then
					return false, string.format("[%s.%s] %s", value:GetFullName(), name, errMsg or "")
				end
			end

			return true
		end
	end
end

return t
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX1467D7557D8B4B6E80F3E41FF93072CF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">sleitnick_signal@2.0.1</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD9B8BFDAA15B40D4BF5DB6AFCF6C0B95">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">signal</string>
							<string name="ScriptGuid">{31A3A036-5F1B-4987-9C80-DCABD69B84DD}</string>
							<ProtectedString name="Source"><![CDATA[-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	Signals allow events to be dispatched and handled.

	For example:
	```lua
	local signal = Signal.new()

	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXB4711CF90FFB4198A3E91E100A637864">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">init.spec</string>
								<string name="ScriptGuid">{30BC70E7-00D0-4CAB-B546-B22CFE2E7126}</string>
								<ProtectedString name="Source"><![CDATA[local function AwaitCondition(predicate, timeout)
	local start = os.clock()
	timeout = (timeout or 10)
	while true do
		if predicate() then
			return true
		end
		if (os.clock() - start) > timeout then
			return false
		end
		task.wait()
	end
end

return function()
	local Signal = require(script.Parent)

	local signal

	local function NumConns(sig)
		sig = sig or signal
		return #sig:GetConnections()
	end

	beforeEach(function()
		signal = Signal.new()
	end)

	afterEach(function()
		signal:Destroy()
	end)

	describe("Constructor", function()
		it("should create a new signal and fire it", function()
			expect(Signal.Is(signal)).to.equal(true)
			task.defer(function()
				signal:Fire(10, 20)
			end)
			local n1, n2 = signal:Wait()
			expect(n1).to.equal(10)
			expect(n2).to.equal(20)
		end)

		it("should create a proxy signal and connect to it", function()
			local signalWrap = Signal.Wrap(game:GetService("RunService").Heartbeat)
			expect(Signal.Is(signalWrap)).to.equal(true)
			local fired = false
			signalWrap:Connect(function()
				fired = true
			end)
			expect(AwaitCondition(function()
				return fired
			end, 2)).to.equal(true)
			signalWrap:Destroy()
		end)
	end)

	describe("FireDeferred", function()
		it("should be able to fire primitive argument", function()
			local send = 10
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:FireDeferred(send)
			expect(AwaitCondition(function()
				return (send == value)
			end, 1)).to.equal(true)
		end)

		it("should be able to fire a reference based argument", function()
			local send = { 10, 20 }
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:FireDeferred(send)
			expect(AwaitCondition(function()
				return (send == value)
			end, 1)).to.equal(true)
		end)
	end)

	describe("Fire", function()
		it("should be able to fire primitive argument", function()
			local send = 10
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:Fire(send)
			expect(value).to.equal(send)
		end)

		it("should be able to fire a reference based argument", function()
			local send = { 10, 20 }
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:Fire(send)
			expect(value).to.equal(send)
		end)
	end)

	describe("ConnectOnce", function()
		it("should only capture first fire", function()
			local value
			local c = signal:ConnectOnce(function(v)
				value = v
			end)
			expect(c.Connected).to.equal(true)
			signal:Fire(10)
			expect(c.Connected).to.equal(false)
			signal:Fire(20)
			expect(value).to.equal(10)
		end)
	end)

	describe("Wait", function()
		it("should be able to wait for a signal to fire", function()
			task.defer(function()
				signal:Fire(10, 20, 30)
			end)
			local n1, n2, n3 = signal:Wait()
			expect(n1).to.equal(10)
			expect(n2).to.equal(20)
			expect(n3).to.equal(30)
		end)
	end)

	describe("DisconnectAll", function()
		it("should disconnect all connections", function()
			signal:Connect(function() end)
			signal:Connect(function() end)
			expect(NumConns()).to.equal(2)
			signal:DisconnectAll()
			expect(NumConns()).to.equal(0)
		end)
	end)

	describe("Disconnect", function()
		it("should disconnect connection", function()
			local con = signal:Connect(function() end)
			expect(NumConns()).to.equal(1)
			con:Disconnect()
			expect(NumConns()).to.equal(0)
		end)

		it("should still work if connections disconnected while firing", function()
			local a = 0
			local c
			signal:Connect(function()
				a += 1
			end)
			c = signal:Connect(function()
				c:Disconnect()
				a += 1
			end)
			signal:Connect(function()
				a += 1
			end)
			signal:Fire()
			expect(a).to.equal(3)
		end)

		it("should still work if connections disconnected while firing deferred", function()
			local a = 0
			local c
			signal:Connect(function()
				a += 1
			end)
			c = signal:Connect(function()
				c:Disconnect()
				a += 1
			end)
			signal:Connect(function()
				a += 1
			end)
			signal:FireDeferred()
			expect(AwaitCondition(function()
				return a == 3
			end)).to.equal(true)
		end)
	end)
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2A53FE257CD54E5EAB0F9E8CA97344B1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">wally</string>
								<string name="ScriptGuid">{F1B8CBD2-C941-4335-8FC0-98A72AB6085A}</string>
								<ProtectedString name="Source"><![CDATA[return {
	package = {
		authors = {"Stephen Leitnick"},
		description = "Signal class",
		exclude = {"node_modules", "package.json", "**/*.ts"},
		license = "MIT",
		name = "sleitnick/signal",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "2.0.1",
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX73BC1D7CC9C74CC79B0C68F1E7851AA6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">t</string>
					<string name="ScriptGuid">{75CC8108-DC56-4E09-A150-EF66B82BBBC1}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["osyrisrblx_t@3.0.0"]["t"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX555A37CC5AC346668BF8395CA49E897A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Plugin</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{CB3A5B08-6490-45A1-941C-448A439042E6}</string>
				<ProtectedString name="Source"><![CDATA[--[[
    blackferrari2's Session Tracker

    Version 2.0
    10th February 2024

    SOURCE:
    https://github.com/blackferrari2/session-tracker
]]

assert(plugin, "SessionTrack must run as a plugin")

if game:GetService("RunService"):IsRunning() then
    return
end

local Session = require(script.Session)
local Settings = require(script.Settings)
local Icons = require(script.Icons)
local Logger = require(script.Session.Logger)
local SessionSave = require(script.Session.SessionSave)
local TotalProjectTime = require(script.Session.TotalProjectTime)
local SessionStatus = require(script.Session.SessionStatus)

local settings = Settings.get()
local Info = settings and require(settings.Info)

---------------

-- if the settings are wrong, abort plugin entirely

if settings then
    local success, errorMessage = Settings.assert(settings)

    if not success then
        local toolbar = plugin:CreateToolbar("BrokenSessionTrack")

        local viewAssertionFailPageButton = toolbar:CreateButton(
            "what happened??",
            "you messed up...",
            Icons.AssertionFailPage
        )

        viewAssertionFailPageButton.Click:Connect(function()
            plugin:OpenScript(script.FailedAssertionLandingPage)
        end)

        error(errorMessage)
    end
end

---------------

local toolbar = plugin:CreateToolbar("SessionTrack")

local powerButton = toolbar:CreateButton(
    "power",
    "turn bot on or off",
    Icons.Power.On
)

local pauseButton = toolbar:CreateButton(
    "pause",
    "pause or resume session",
    Icons.Pause.Unpaused
)

local settingsButton = toolbar:CreateButton(
    "settings",
    "open settings widget",
    Icons.Settings
)

local initializeButton = toolbar:CreateButton(
    "initialize",
    "create new settings",
    Icons.Initialize
)

local deleteProjectButton = toolbar:CreateButton(
    "delete",
    "delete your project",
    Icons.Delete
)

--

local settingsWidgetButtonHeight = 40
local settingsWidget = plugin:CreateDockWidgetPluginGui("SessionTrackSettings", DockWidgetPluginGuiInfo.new(
    Enum.InitialDockState.Float,
    false,
    true,
    settingsWidgetButtonHeight * 5,
    settingsWidgetButtonHeight * 5,
    settingsWidgetButtonHeight * 5,
    settingsWidgetButtonHeight * 5
))

local deleteProjectPromptWidgetButtonHeight = 70
local deleteProjectPromptWidget = plugin:CreateDockWidgetPluginGui("SessionTrackDeleteProject", DockWidgetPluginGuiInfo.new(
    Enum.InitialDockState.Float,
    false,
    true,
    400,
    400,
    400,
    400
))

--

local function toggleSessionButtons(offOrOn: boolean)
    powerButton.Enabled = offOrOn
    pauseButton.Enabled = offOrOn
end

---------------

-- setup the settings widget

settingsWidget.Title = "select what you wanna edit"

local scroll = Instance.new("ScrollingFrame")
Instance.new("UIListLayout", scroll)

scroll.Size = UDim2.fromScale(1, 1)
scroll.Position = UDim2.fromScale(0, 0)
scroll.BackgroundColor3 = Color3.new(0, 0, 0)
scroll.Parent = settingsWidget

-- setup project delete widget

deleteProjectPromptWidget.Title = "SessionTrack DELETE"

local warningLabel = Instance.new("TextLabel")

warningLabel.Text = "Are you sure you want to erase all your project data?"
warningLabel.Size = UDim2.new(UDim.new(1, 0), UDim.new(0, deleteProjectPromptWidgetButtonHeight))
warningLabel.Position = UDim2.fromScale(0, 0)
warningLabel.BackgroundColor3 = Color3.new(0, 0, 0)
warningLabel.TextColor3 = Color3.new(1, 1, 1)
warningLabel.Parent = deleteProjectPromptWidget

local confirmButton = Instance.new("TextButton")

confirmButton.Text = "YES"
confirmButton.Size = UDim2.new(UDim.new(1, 0), UDim.new(0, deleteProjectPromptWidgetButtonHeight))
confirmButton.Position = UDim2.new(UDim.new(0, 0), UDim.new(0, deleteProjectPromptWidgetButtonHeight * 2))
confirmButton.BackgroundColor3 = Color3.new(0, 0, 0)
confirmButton.TextColor3 = Color3.new(1.000000, 0.462745, 0.462745)
confirmButton.TextSize = deleteProjectPromptWidgetButtonHeight - 15
confirmButton.Font = Enum.Font.Arcade
confirmButton.Parent = deleteProjectPromptWidget

local rejectButton = Instance.new("TextButton")

rejectButton.Text = "NO"
rejectButton.Size = UDim2.new(UDim.new(1, 0), UDim.new(0, deleteProjectPromptWidgetButtonHeight))
rejectButton.Position = UDim2.new(UDim.new(0, 0), UDim.new(0, deleteProjectPromptWidgetButtonHeight * 3))
rejectButton.BackgroundColor3 = Color3.new(0, 0, 0)
rejectButton.TextColor3 = Color3.new(0.462745, 1.000000, 0.552941)
rejectButton.TextSize = deleteProjectPromptWidgetButtonHeight - 15
rejectButton.Font = Enum.Font.Arcade
rejectButton.Parent = deleteProjectPromptWidget

-- configure initial button states

if settings then
    initializeButton.Enabled = false
    deleteProjectButton.Enabled = true
else
    settingsButton.Enabled = false
    powerButton.Enabled = false
    deleteProjectButton.Enabled = false
end

pauseButton.Enabled = false

-- if theres a recovered session detected, switch out the power button icon

if settings and SessionSave.recover(plugin, Info.ProjectName) then
    Icons.switch(powerButton, Icons.Power.Recover)
end

---------------

-- button handling

local totalProjectTime = settings and TotalProjectTime.new(plugin, Info.ProjectName, settings)
local save = settings and SessionSave.new(plugin, Info.ProjectName, 1)

local session
local logger

powerButton.Click:Connect(function()
    toggleSessionButtons(false)

    if session then
        Icons.switch(powerButton, Icons.Power.On)
        Icons.switch(pauseButton, Icons.Pause.Unpaused)
        
        session:close()        
        totalProjectTime:commit(totalProjectTime:get() + session.status:getTimeElapsed())
        session:destroy()
        logger:destroy()
        save:stopAutosaving()
        save:erase()

        session = nil
        logger = nil
        toggleSessionButtons(true)
        deleteProjectButton.Enabled = true

        return
    end

    Icons.switch(powerButton, Icons.Power.Off)
    deleteProjectButton.Enabled = false

    session = Session.new()
    logger = Logger.new(settings, session.status, totalProjectTime)

    local recoveredSessionStatus, timeSinceLastSave = SessionSave.recover(plugin, Info.ProjectName)

    if recoveredSessionStatus then
        session:startFromRecoveredSession(logger, recoveredSessionStatus, timeSinceLastSave)

        -- session recovered to paused state, change icons to reflect that
        if recoveredSessionStatus.state == SessionStatus.States.Paused then
            Icons.switch(pauseButton, Icons.Pause.Paused)
        end
    else
        session:start(logger)
    end

    save:startAutosaving(session)
    toggleSessionButtons(true)
end)

--

pauseButton.Click:Connect(function()
    if not session then
        return
    end

    toggleSessionButtons(false)

    if session.status.state == SessionStatus.States.Paused then
        Icons.switch(pauseButton, Icons.Pause.Unpaused)
        session:resume()
        toggleSessionButtons(true)
        return
    end

    Icons.switch(pauseButton, Icons.Pause.Paused)
    session:pause()
    toggleSessionButtons(true)
end)

--

local function createSettingsWidgetButtons(settings: Settings.Settings)
    for _, module in pairs(settings:GetChildren()) do
        local oldButton = scroll:FindFirstChild(module.Name)

        if oldButton then
            oldButton:Destroy()
        end

        local openScriptButton = Instance.new("TextButton")
    
        openScriptButton.Text = module.Name
        openScriptButton.Name = module.Name
        openScriptButton.Size = UDim2.new(UDim.new(1, 0), UDim.new(0, settingsWidgetButtonHeight))
        openScriptButton.Font = Enum.Font.Arcade
        openScriptButton.TextSize = settingsWidgetButtonHeight - 15
        openScriptButton.TextStrokeTransparency = 0
        openScriptButton.TextColor3 = Color3.new(1, 1, 1)
        openScriptButton.BackgroundColor3 = Color3.new(0, 0, 0)
        openScriptButton.Parent = scroll
    end
end

local function setupSettingsWidgetButtonsEvents(settings: Settings.Settings)
    for _, module in pairs(settings:GetChildren()) do
        local openScriptButton = scroll:FindFirstChild(module.Name)
    
        openScriptButton.Activated:Connect(function()
            plugin:OpenScript(module)
            settingsWidget.Enabled = false
        end)
    end
end

settingsButton.Click:Connect(function()
    if not settings then
        return
    end

    createSettingsWidgetButtons(settings)
    setupSettingsWidgetButtonsEvents(settings)

    settingsWidget.Enabled = not settingsWidget.Enabled
end)

--

initializeButton.Click:Connect(function()
    if settings then
        return
    end

    settingsButton.Enabled = true
    initializeButton.Enabled = false
    deleteProjectButton.Enabled = true

    settings = Settings.new()
    plugin:OpenScript(settings.Info)
end)

--

deleteProjectButton.Click:Connect(function()
    if not settings then
        return
    end

    deleteProjectPromptWidget.Enabled = not deleteProjectPromptWidget.Enabled
end)

rejectButton.Activated:Connect(function()
    deleteProjectPromptWidget.Enabled = false
end)

confirmButton.Activated:Connect(function()
    if not settings then
        return
    end

    if session then
        return
    end

    deleteProjectPromptWidget.Enabled = false

    powerButton.Enabled = false
    pauseButton.Enabled = false
    initializeButton.Enabled = false
    settingsButton.Enabled = false
    deleteProjectButton.Enabled = false

    if totalProjectTime then
        totalProjectTime:erase()
    end

    if save then
        save:erase()
    end
    
    settings:Destroy()
    plugin:OpenScript(script.ProjectDeletedLandingPage)
end)

---------------]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX7DBD854893704F30860F74FAAEE908DD">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">FailedAssertionLandingPage</string>
					<string name="ScriptGuid">{AE31CEB1-3120-4C11-8423-D5A8D50B864C}</string>
					<ProtectedString name="Source"><![CDATA[--[[
                       ██████   ██████  ██████  ███████          
                      ██    ██ ██    ██ ██   ██ ██               
                      ██    ██ ██    ██ ██████  ███████          
                      ██    ██ ██    ██ ██           ██          
                       ██████   ██████  ██      ███████ ██ ██ ██ 
                            
                       
    ...........

    WHAT DID YOU DO???
        If you can see this page then your settings are setup incorrectly.

    Check your output (View > Output) for the error info
        FYI, your settings folder is located in ServerStorage, under the name "SessionTrack.PluginSettings"

    ...........

    Once the issue is fixed, save and reload studio to apply your new settings!
]]]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCE70BB18EDB7476AA5811339C8C16520">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Icons</string>
					<string name="ScriptGuid">{2F52B152-760A-4C55-A37C-9D2E30D0CFCE}</string>
					<ProtectedString name="Source"><![CDATA[local Icons = {
    Power = {
        On = "http://www.roblox.com/asset/?id=16008923978",
        Off = "http://www.roblox.com/asset/?id=16008923312",
        Recover = "http://www.roblox.com/asset/?id=16025418149",
    },

    Pause = {
        Paused = "http://www.roblox.com/asset/?id=16008921548",
        Unpaused = "http://www.roblox.com/asset/?id=16008922394",
    },

    Settings = "http://www.roblox.com/asset/?id=16008920257",
    Initialize = "http://www.roblox.com/asset/?id=16008985266",
    Delete = "http://www.roblox.com/asset/?id=14219067357",
    AssertionFailPage = "http://www.roblox.com/asset/?id=14219067357",
}

---------------

-- here because theres this weird bug where if you change the .Icon id to the same one its already using, the icon turns invisible
function Icons.switch(this: PluginToolbarButton, to: string)
    if this.Icon == to then
        return
    end

    this.Icon = to
end

---------------

return Icons]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX224A5A98E04443DB998C1980676341BE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ProjectDeletedLandingPage</string>
					<string name="ScriptGuid">{3919D6E0-AF5E-4121-AC16-EFA630C257AB}</string>
					<ProtectedString name="Source"><![CDATA[--[[
                                                         
                         8I                                              
                         8I                                              
                         8I                                              
                         8I                                              
                   ,gggg,8I    ,gggg,gg   ,ggg,,ggg,,ggg,    ,ggg,,ggg,  
                  dP"  "Y8I   dP"  "Y8I  ,8" "8P" "8P" "8,  ,8" "8P" "8, 
                 i8'    ,8I  i8'    ,8I  I8   8I   8I   8I  I8   8I   8I 
                ,d8,   ,d8b,,d8,   ,d8b,,dP   8I   8I   Yb,,dP   8I   Yb,
                P"Y8888P"`Y8P"Y8888P"`Y88P'   8I   8I   `Y88P'   8I   `Y8
                            
                       
    ...........

    You've deleted all your SessionTrack project data.

    Please restart studio to reset the plugin back to its factory settings.
]]]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXEBC688100DEE47E5A51E33116205D33F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Session</string>
					<string name="ScriptGuid">{A8EA3CC5-A3AA-4039-B41B-A817C28D9A26}</string>
					<ProtectedString name="Source"><![CDATA[local SessionStatus = require(script.SessionStatus)
local Logger = require(script.Logger)

local Session = {}
Session.__index = Session

---------------

type self = {
    status: SessionStatus.SessionStatus,
    logger: Logger.Logger?,
}

export type Session = typeof(setmetatable({} :: self, Session))

-------------

function Session.new(): Session
    local self = {
        status = SessionStatus.new(),
    }

    setmetatable(self, Session)

    return self
end

function Session.start(self: Session, logger: Logger.Logger)
    if self.status.state ~= SessionStatus.States.DidntStart then
        return
    end

    self.logger = logger
    self.status:changeState(SessionStatus.States.Ongoing)
    logger:postSessionStartMessage()
    logger:loopCheckpointPosting()
end

function Session.startFromRecoveredSession(self: Session, logger: Logger.Logger, recoveredSessionStatus: SessionStatus.SessionStatus, timeSinceLastSave: number)
    if self.status.state ~= SessionStatus.States.DidntStart then
        return
    end

    self.logger = logger
    self.status:changeState(recoveredSessionStatus.state)
    self.status.timePassed = recoveredSessionStatus.timePassed

    -- if the recovered session wasnt paused, we need to recalculate the timePassed
    -- so that we ignore the time inbetween losing the session and recovering it
    if recoveredSessionStatus.state == SessionStatus.States.Ongoing then
        self.status.timePassed = recoveredSessionStatus:getTimeElapsed() - timeSinceLastSave
        logger:loopCheckpointPosting()
    end

    logger:postSessionRecoveredMessage()
end

function Session.pause(self: Session)
    if self.status.state ~= SessionStatus.States.Ongoing then
        return
    end

    assert(self.logger)
    self.status:changeState(SessionStatus.States.Paused)
    self.logger:stopCheckpointLoop()
    self.logger:postSessionPauseMessage()
end

function Session.resume(self: Session)
    if self.status.state ~= SessionStatus.States.Paused then
        return
    end

    assert(self.logger)
    self.status:changeState(SessionStatus.States.Ongoing)
    self.logger:postSessionResumeMessage()
    self.logger:loopCheckpointPosting()
end

function Session.close(self: Session)
    assert(self.logger)
    self.status:changeState(SessionStatus.States.Closed)
    self.logger:postSessionCloseMessage()
    self.logger = nil
end

function Session.destroy(self: Session)
    self.status:changeState(SessionStatus.States.Closed)
    self.status:destroy()
    self.logger = nil

    local setmetatable: any = setmetatable
    setmetatable(self, nil)
end

---------------

return Session]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD3AB1197F9C54DAE9D2D75841FAA89FC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Logger</string>
						<string name="ScriptGuid">{03486912-C65D-4674-AACC-5D7553087B13}</string>
						<ProtectedString name="Source"><![CDATA[local settingsDirectory = script.Parent.Parent.Settings
local packages = script.Parent.Parent.Parent.Packages

local SessionStatus = require(script.Parent.SessionStatus)
local TotalProjectTime = require(script.Parent.TotalProjectTime)
local Settings = require(settingsDirectory)
local Messages = require(settingsDirectory.Modules.Messages)
local Checkpoints = require(settingsDirectory.Modules.Checkpoints)
local Info = require(settingsDirectory.Modules.Info)
local Voyager = require(packages.Voyager)

local Logger = {
    Tags = {
        DayToday = "TODAYSDATE",
        SessionState = "SESSIONSTATE",
        SessionTime = "SESSIONTIME",
        TotalTime = "TOTALTIME",
    }
}

Logger.__index = Logger

---------------

type self = {
    settings: Settings.Settings,
    messages: Messages.Messages,
    checkpoints: Checkpoints.Checkpoints,
    info: Info.Info,
    sessionStatus: SessionStatus.SessionStatus,
    totalProjectTime: TotalProjectTime.TotalProjectTime,
    webhook: typeof(Voyager)?,
    checkpointLoopThread: thread?,
}

export type Logger = typeof(setmetatable({} :: self, Logger))

-------------

local function formatSecondsToHMS(time)
    local seconds = math.floor(time % 60)
    local minutes = math.floor(time / 60) % 60
    local hours = math.floor(time / 3600) % 24

    return string.format("%s Hours, %s Minutes and %s Seconds", hours, minutes, seconds)
end

local function formatSecondsToDHMS(time)
    local seconds = math.floor(time % 60)
    local minutes = math.floor(time / 60) % 60
    local hours = math.floor(time / 3600) % 24
    local days = math.floor(time / 86400)

    return string.format("%s Days, %s Hours, %s Minutes and %s Seconds", days, hours, minutes, seconds)
end

-------------

function Logger.new(settings: Settings.Settings, sessionStatus: SessionStatus.SessionStatus, totalProjectTime: TotalProjectTime.TotalProjectTime): Logger
    local self = {
        settings = settings,
        messages = require(settings.Messages),
        checkpoints = require(settings.Checkpoints),
        info = require(settings.Info),
        sessionStatus = sessionStatus,
        totalProjectTime = totalProjectTime,
    }

    if not self.info.UseOutputInstead then
        self.webhook = Voyager.fromUrl(self.info.WebhookURL)
    end

    setmetatable(self, Logger)

    return self
end

function Logger.send(self: Logger, text: string?)
    if not text then
        return
    end

    text = self:getTextWithTagsApplied(text)

    if self.webhook then
        self.webhook:execute(text, nil, false, true)
    else
        print(text)
    end
end

function Logger.getTextWithTagsApplied(self: Logger, text: string)
    local applications = {
        [Logger.Tags.DayToday] = os.date(),
        [Logger.Tags.SessionTime] = formatSecondsToHMS(self.sessionStatus:getTimeElapsed()),
        [Logger.Tags.TotalTime] = formatSecondsToDHMS(self.totalProjectTime:get() + self.sessionStatus:getTimeElapsed()),
        [Logger.Tags.SessionState] = self.sessionStatus.state,
    }
    
    return string.gsub(text, "%u+", applications)
end

function Logger.destroy(self: Logger)
    self:stopCheckpointLoop()

    local setmetatable: any = setmetatable
    setmetatable(self, nil)
end

--

function Logger.postSessionStartMessage(self: Logger)
    local message = self.messages.get(self.messages.Start)
    local separator = self.messages.get(self.messages.LineSeparators)

    self:send(message)
    self:send(separator) 
end

function Logger.postSessionRecoveredMessage(self: Logger)
    local message = self.messages.get(self.messages.SessionRecovered)
    
    self:send(message)
end

function Logger.postCheckpoint(self: Logger)
    local checkpoint = self.checkpoints.get()
        
    self:send(checkpoint)
end

function Logger.loopCheckpointPosting(self: Logger)
    if self.checkpointLoopThread then
        return
    end

    self.checkpointLoopThread = task.spawn(function()
        local interval = self.checkpoints.IntervalSeconds

        while task.wait(interval) do
            self:postCheckpoint()
        end
    end)
end

function Logger.stopCheckpointLoop(self: Logger)
    if self.checkpointLoopThread then
        task.cancel(self.checkpointLoopThread)
        self.checkpointLoopThread = nil 
    end
end

function Logger.postSessionPauseMessage(self: Logger)
    local message = self.messages.get(self.messages.Pause)

    self:send(message)
end

function Logger.postSessionResumeMessage(self: Logger)
    local message = self.messages.get(self.messages.Resume)
    
    self:send(message)
end

function Logger.postSessionCloseMessage(self: Logger)
    local separator = self.messages.get(self.messages.LineSeparators)
    local message = self.messages.get(self.messages.Close)

   self:send(separator)
   self:send(message)
end

---------------

return Logger]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD9DACC434BC34CC487E8091227C22C34">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SessionSave</string>
						<string name="ScriptGuid">{B809DDFE-BE71-4875-96D6-C75AB709D244}</string>
						<ProtectedString name="Source"><![CDATA[local Session = require(script.Parent)
local SessionStatus = require(script.Parent.SessionStatus)

local SessionSave = {
    Key = "SessionTrackAutosave%s",
}

SessionSave.__index = SessionSave

---------------

type self = {
    plugin: Plugin,
    projectName: string,
    intervalSeconds: number,
    latestSessionStatus: SessionStatus.SessionStatus?,
    latestCommitTick: number?,
    autosaveThread: thread?,
}

export type SessionSave = typeof(setmetatable({} :: self, SessionSave))

-------------

local function getKey(projectName)
    return string.format(SessionSave.Key, projectName)
end

-------------

function SessionSave.new(plugin: Plugin, projectName: string, intervalSeconds: number?): SessionSave
    local self = {
        plugin = plugin,
        projectName = projectName,
        intervalSeconds = intervalSeconds or 5,
    }

    setmetatable(self, SessionSave)

    return self
end

function SessionSave.recover(plugin: Plugin, projectName: string): (SessionStatus.SessionStatus?, number?)
    local recoveredSave = plugin:GetSetting(getKey(projectName))

    if not recoveredSave then
        return
    end

    -- plugin:GetSetting() doesnt save the metatables so we need to put them back
    setmetatable(recoveredSave, SessionSave)
    setmetatable(recoveredSave.latestSessionStatus, SessionStatus)

    return recoveredSave.latestSessionStatus, recoveredSave:getTimeSinceLastSave()
end

function SessionSave.getTimeSinceLastSave(self: SessionSave): number
    if not self.latestCommitTick then
        return 0
    end

    return tick() - self.latestCommitTick
end

function SessionSave.commit(self: SessionSave, status: SessionStatus.SessionStatus)
    self.latestSessionStatus = status:clone()
    self.latestCommitTick = tick()
    self.plugin:SetSetting(getKey(self.projectName), self)
end

function SessionSave.erase(self: SessionSave)
    self.latestSessionStatus = nil
    self.latestCommitTick = nil
    self.plugin:SetSetting(getKey(self.projectName), nil)
end

function SessionSave.startAutosaving(self: SessionSave, session: Session.Session)
    if self.autosaveThread then
        return
    end

    self.autosaveThread = task.spawn(function()
        self:commit(session.status)

        while task.wait(self.intervalSeconds) do
            self:commit(session.status)
        end
    end)
end

function SessionSave.stopAutosaving(self: SessionSave)
    if not self.autosaveThread then
        return
    end

    task.cancel(self.autosaveThread)
    self.autosaveThread = nil
end

function SessionSave.destroy(self: SessionSave)
    self:stopAutosaving()
    self:erase()

    local setmetatable: any = setmetatable
    setmetatable(self, nil)
end

---------------

return SessionSave]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBBF78D54B7FC4AF08775AC47407EE169">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SessionStatus</string>
						<string name="ScriptGuid">{108FA5A1-4D66-4326-A4EC-21678E3B7B48}</string>
						<ProtectedString name="Source"><![CDATA[local packages = script.Parent.Parent.Parent.Packages

local Signal = require(packages.Signal)

local SessionStatus = {
    States = {
        DidntStart = "DidntStart",
        Ongoing = "Ongoing",
        Paused = "Paused",
        Closed = "Closed",
    },
}

SessionStatus.__index = SessionStatus

---------------

type self = {
    state: State,
    stateChanged: Signal.Signal<State>,
    timePassed: number,
    timeStarted: number,
}

export type State = "DidntStart" | "Ongoing" | "Paused" | "Closed"
export type SessionStatus = typeof(setmetatable({} :: self, SessionStatus))

-------------

function SessionStatus.new(): SessionStatus
    local self = {
        state = SessionStatus.States.DidntStart,
        stateChanged = Signal.new(),
        timePassed = 0,
        timeStarted = nil,
    }

    setmetatable(self, SessionStatus)

    return self
end

function SessionStatus.changeState(self: SessionStatus, to: State)
    if to == SessionStatus.States.Ongoing then
        self.timeStarted = tick()
    end

    if to == SessionStatus.States.Paused or to == SessionStatus.States.Closed then
        self.timePassed = self:getTimeElapsed()
    end

    self.state = to
    self.stateChanged:Fire(to)
end

function SessionStatus.getTimeElapsed(self: SessionStatus): number
    if self.state == SessionStatus.States.DidntStart then
        return 0
    end

    if self.state == SessionStatus.States.Paused or self.state == SessionStatus.States.Closed then
        return self.timePassed
    end

    local timeElapsedSoFar = tick() - self.timeStarted

    return self.timePassed + timeElapsedSoFar
end

-- creates a safe clone for `plugin:SetSetting()`. it cant save Signal objects.
function SessionStatus.clone(self: SessionStatus): SessionStatus
    local clone = SessionStatus.new()

    clone.state = self.state
    clone.timeStarted = self.timeStarted
    clone.timePassed = self.timePassed
    clone.stateChanged:DisconnectAll()
    clone.stateChanged = nil

    return clone
end

function SessionStatus.destroy(self: SessionStatus)
    self:changeState(SessionStatus.States.Closed)
    self.stateChanged:Destroy()

    local setmetatable: any = setmetatable
    setmetatable(self, nil)
end

---------------

return SessionStatus]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB0EA1ED257BB4DE4877C28702F3D19BA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TotalProjectTime</string>
						<string name="ScriptGuid">{EE8141BC-D34B-482C-979E-D030CF6F2BE1}</string>
						<ProtectedString name="Source"><![CDATA[local TotalProjectTime = {
    Key = "SessionTrackTotalTime%s",
    FailsafeAttribute = "TotalProjectTime",
}

TotalProjectTime.__index = TotalProjectTime

---------------

type self = {
    plugin: Plugin,
    projectName: string,
    failsafe: Instance,
}

export type TotalProjectTime = typeof(setmetatable({} :: self, TotalProjectTime))

-------------

local function getKey(projectName)
    return string.format(TotalProjectTime.Key, projectName)
end

-------------

function TotalProjectTime.new(plugin: Plugin, projectName: string, failsafe: Instance): TotalProjectTime
    local self = {
        plugin = plugin,
        projectName = projectName,
        failsafe = failsafe,
    }

    setmetatable(self, TotalProjectTime)

    return self
end

function TotalProjectTime.commit(self: TotalProjectTime, newTime: number)
    self.failsafe:SetAttribute(TotalProjectTime.FailsafeAttribute, newTime)
    self.plugin:SetSetting(getKey(self.projectName), newTime)
end

function TotalProjectTime.erase(self: TotalProjectTime)
    self.failsafe:SetAttribute(TotalProjectTime.FailsafeAttribute, nil)
    self.plugin:SetSetting(getKey(self.projectName), nil)
end

function TotalProjectTime.get(self: TotalProjectTime)
    local total = self.plugin:GetSetting(getKey(self.projectName))

    if not total then
        local recoveredTotalTime = self.failsafe:GetAttribute(TotalProjectTime.FailsafeAttribute)

        total = recoveredTotalTime or 0
    end

    return total
end

---------------

return TotalProjectTime]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX4515098B05534F3DA12DA31286261D68">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Settings</string>
					<string name="ScriptGuid">{102BC33E-6DFE-4E16-849E-BDAB0219E65D}</string>
					<ProtectedString name="Source"><![CDATA[local ServerStorage = game:GetService("ServerStorage")

local bases = script.Modules
local assertions = script.Assertions

local Messages = require(bases.Messages)
local Checkpoints = require(bases.Checkpoints)
local Info = require(bases.Info)

local Settings = {
    Version = 3,
    InstanceName = "SessionTrack.PluginSettings",
    OutdatedInstanceName = "[OUTDATED] SessionTrack.PluginSettings",
    VersionAttribute = "Version",
}

---------------

export type Settings = Folder & {
    Messages: Messages.Messages,
    Checkpoints: Checkpoints.Checkpoints,
    Info: Info.Info,
}

---------------

local PRINT_NEW_SETTINGS = "[SessionTrack]: created new settings folder!"
local WARN_OUTDATED_SETTINGS = "[SessionTrack]: your settings are outdated. please migrate your stuff over to a new copy. the old copy was renamed and you can still view it - its in ServerStorage"
local ASSERTFAIL_INVALID_INSTANCE = "[SessionTrack]: %s found in settings folder. ModuleScripts ONLY please"
local ASSERTFAIL_INVALID_NAME = "[SessionTrack]: the module name of %s is invalid. Please change it back to its original name (either that or its not a module found in the original settings.)"
local ASSERTFAIL_CANT_LOAD_MODULE = "[SessionTrack]: couldnt load settings module %s. %s"

---------------

function Settings.new(): Settings
    local clone = bases:Clone()

    clone.Name = Settings.InstanceName
    clone:SetAttribute(Settings.VersionAttribute, Settings.Version)
    clone.Parent = ServerStorage

    print(PRINT_NEW_SETTINGS)

    return clone
end

function Settings.get(): Folder?
    local modules = ServerStorage:FindFirstChild(Settings.InstanceName)

    if modules then
        if modules:GetAttribute(Settings.VersionAttribute) ~= Settings.Version then
            warn(WARN_OUTDATED_SETTINGS)

            modules.Name = Settings.OutdatedInstanceName

            return nil
        end

        return modules
    end

    return nil
end

function Settings.assert(root: Settings): (boolean, string?)
    for _, module in pairs(root:GetChildren()) do
        if module.ClassName ~= "ModuleScript" then
            return false, string.format(ASSERTFAIL_INVALID_INSTANCE, module.ClassName)
        end

        local assertion = assertions:FindFirstChild(module.Name)

        if not assertion then
            return false, string.format(ASSERTFAIL_INVALID_NAME, module.Name)
        end

        local loadedModule
        local _, errorMessage = pcall(function() 
            loadedModule = require(module)
        end)

        if errorMessage then
            return false, string.format(ASSERTFAIL_CANT_LOAD_MODULE, module.Name, errorMessage)
        end

        assertion = require(assertion)

        local moduleChecksPassed, moduleErrorMessage = assertion.run(loadedModule)

        if not moduleChecksPassed then
            return moduleChecksPassed, moduleErrorMessage
        end
    end

    return true
end

---------------

return Settings]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXAF95D106202A4C578B895B9F6D2FC3D1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Assertions</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2C79805C928D48DCACD979E60B524C2A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Assets</string>
							<string name="ScriptGuid">{E84E3235-1663-436D-AC2D-687462DC80A6}</string>
							<ProtectedString name="Source"><![CDATA[-- nothing to check lol

local AssetsAssertion = {}

---------------

function AssetsAssertion.run(): boolean
    return true
end

---------------

return AssetsAssertion]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4AEF4D0BF1DF44DABBC3ABE38A2B8439">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Checkpoints</string>
							<string name="ScriptGuid">{85C88015-6637-4F6C-BF88-B192A71A89E1}</string>
							<ProtectedString name="Source"><![CDATA[local packages = script.Parent.Parent.Parent.Parent.Packages
local baseModules = script.Parent.Parent.Modules

local t = require(packages.t)
local Checkpoints = require(baseModules.Checkpoints)

local CheckpointsAssertion = {}

---------------

local ASSERTFAIL_PREFIX = "[SessionTrack]: CHECKPOINTS FAILED TO LOAD - "

local checkpointInterface = t.interface({
    author = t.string,
    message = t.string,
})

local moduleInterface = t.interface({
    IntervalSeconds = t.numberMin(60),
})

---------------

function CheckpointsAssertion.run(module: Checkpoints.Checkpoints): (boolean, string?)
    local success, errorMessage = moduleInterface(module)

    if not success then
        return success, ASSERTFAIL_PREFIX .. errorMessage
    end

    for _, checkpoint in ipairs(module) do
        success, errorMessage = checkpointInterface(checkpoint)

        if not success then
            return success, ASSERTFAIL_PREFIX .. "checkpoints arent structured correctly. Did you mess with the .add() function? | " .. errorMessage
        end
    end

    local checkpoint
    success, errorMessage = pcall(function()
        checkpoint = module.get()
    end)

    if not success then
        return success, ASSERTFAIL_PREFIX .. errorMessage
    end

    success, errorMessage = t.optional(t.string)(checkpoint)

    if not success then
        return success, ASSERTFAIL_PREFIX .. "checkpoints.get() dont return text for some reason. What did you DO? | " .. errorMessage
    end

    return true
end

---------------

return CheckpointsAssertion]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB0A04509E95448F8AEEF3944CFE057D9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Info</string>
							<string name="ScriptGuid">{91570FFD-C322-4373-8120-21D080CA6ACC}</string>
							<ProtectedString name="Source"><![CDATA[local packages = script.Parent.Parent.Parent.Parent.Packages
local baseModules = script.Parent.Parent.Modules

local t = require(packages.t)
local Voyager = require(packages.Voyager)
local Info = require(baseModules.Info)

local InfoAssertion = {}

---------------

local ASSERTFAIL_PREFIX = "[SessionTrack]: INFO FAILED TO LOAD - "

local moduleInterface = t.interface({
    ProjectName = t.string,
    WebhookURL = t.string,
    UseOutputInstead = t.boolean,
})

---------------

function InfoAssertion.run(module: Info.Info): (boolean, string?)
    local success, errorMessage = moduleInterface(module)

    if not success then
        return success, ASSERTFAIL_PREFIX .. errorMessage
    end

    success, errorMessage = pcall(function()
        if module.UseOutputInstead then
            return
        end

        local webhook = Voyager.fromUrl(module.WebhookURL)
        local message, requestStatus = webhook:execute("Plugin is starting... (This is a check to see if the webhook actually works). Message will be deleted.", nil, false, true)

        if not requestStatus.success then
            error("Webhook fails to send messages. Proxy request status and code: " .. requestStatus.statusMessage .. " " .. requestStatus.statusCode)
        else
            webhook:deleteMessage(message.id)
        end
    end)

    if not success then
        return success, ASSERTFAIL_PREFIX .. errorMessage
    end

    return true
end

---------------

return InfoAssertion]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8EED1588318E405EA7A53079BA5ED6DE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Messages</string>
							<string name="ScriptGuid">{8BFB441A-1C40-49D2-BA83-2882E66F2120}</string>
							<ProtectedString name="Source"><![CDATA[local packages = script.Parent.Parent.Parent.Parent.Packages
local baseModules = script.Parent.Parent.Modules

local t = require(packages.t)
local Messages = require(baseModules.Messages)

local MessagesAssertion = {}

---------------

local ASSERTFAIL_PREFIX = "[SessionTrack]: MESSAGES FAILED TO LOAD - "

local messageList = t.array(t.string)

local moduleInterface = t.interface({
    Start = messageList,
    SessionRecovered = messageList,
    Close = messageList,
    Pause = messageList,
    Resume = messageList,
    LineSeparators = messageList,
})

---------------

function MessagesAssertion.run(module: Messages.Messages): (boolean, string?)
    local success, errorMessage = moduleInterface(module)

    if not success then
        return success, ASSERTFAIL_PREFIX .. "the module isnt structured correctly. Did you mess with the .add() function? | " .. errorMessage
    end

    local message
    success, errorMessage = pcall(function()
        message = module.get(Messages.Start)
    end)

    if not success then
        return success, ASSERTFAIL_PREFIX .. errorMessage
    end

    success, errorMessage = t.optional(t.string)(message)

    if not success then
        return success, ASSERTFAIL_PREFIX .. "messages arent text for some reason. What did you DO? | " .. errorMessage
    end

    return true
end

---------------

return MessagesAssertion]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX51485AA3B71846478192746200E35DD7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Modules</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXAA3F2F163D70494FA1F608918BA1F12E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Assets</string>
							<string name="ScriptGuid">{3FA48D01-858D-4142-9B52-85F441A54162}</string>
							<ProtectedString name="Source"><![CDATA[--[[
    NOTE:

    SAVE AND RESTART STUDIO TO APPLY CHANGES.
]]

--[[
    plugin assets

    not used for anything in particular other than to spice up messages and checkpoints. Feel free to do anything with this
]]

local Assets = {
    Emojis = {
        Smiley = "🙂",
        Angry = "😡",
        Rat = "🐀",
    },
}

---------------

return Assets]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX59A1DDC8557F45C29BBCE363671BB396">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Checkpoints</string>
							<string name="ScriptGuid">{EA5D5B8D-F002-427C-9C55-3AEC296700F1}</string>
							<ProtectedString name="Source"><![CDATA[--[[
    NOTE:

    SAVE AND RESTART STUDIO TO APPLY CHANGES.
]]

--[[
    Checkpoints are random messages that are sent during a session.

    scroll down
    ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
]]

local Assets = require(script.Parent.Assets)

local Checkpoints = {
    -- Minimum value: 60 seconds
    IntervalSeconds = 600,
}

---------------

export type Checkpoints = typeof(Checkpoints)

---------------

local FORMAT = "[%s]: %s"

---------------

function Checkpoints.add(author: string, message: string)
    local checkpoint = {
        author = author,
        message = message
    }

    table.insert(Checkpoints, checkpoint)
end

function Checkpoints.get(): string?
    if #Checkpoints < 1 then
        return nil
    end

    local randomCheckpoint = math.random(1, #Checkpoints)
    local checkpoint = Checkpoints[randomCheckpoint]

    return string.format(FORMAT, checkpoint.author, checkpoint.message)
end

---------------

--[[
    ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ 
    ADD MORE CHECKPOINTS HERE
    ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ 

    If you dont want checkpoints to be sent, do not add any.

    Example:
        Checkpoints.add("TestAuthor", "hey")
]]

--[[
    SPECIAL TAGS
    spice up your checkpoints with them

    ...

    SESSIONTIME
        time spent on the current session

    TOTALTIME
        total time spent on the project

    TODAYSDATE
        day, hour, minute, second right now

    SESSIONSTATE
        state of the session (paused or ongoing)

    ...
]]

Checkpoints.add("TestAuthor", "hey" .. Assets.Emojis.Smiley)
Checkpoints.add("TestAuthor2", "helolo SESSIONTIME")

---------------

return Checkpoints]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB8B61F1B01C94EC49384B20597FEE689">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Info</string>
							<string name="ScriptGuid">{73091103-490E-4CBB-969F-2C8AD3422B9E}</string>
							<ProtectedString name="Source"><![CDATA[--[[
    ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★

    HELLO! thanks for using my plugin

    FOR IT TO WORK, first replace the `WebhookURL` field down there with the url of your discord webhook

    save and restart studio afterwards to apply the changes. Enjoy!
        (you can close this after youre done)


    ...........

    QnA:
        Reset/Delete settings?
            > delete/take out the `SessionTrack.PluginSettings` folder from ServerStorage and save and restart studio afterwards like normal.

        settings are GONE?
            > your settings mightve been outdated (check the output to confirm that and for more instructions). They werent deleted.


    ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★  ★ 
]]

--[[
    info about your project

    please edit the fields with "REPLACEME" for the plugin to work properly.

    if you wanna test the plugin without posting to the webhook, change the `UseOutputInstead` option to `true`.
        thatll, like the name says, send all the messages to roblox studios output
            set it back to `false` once youre done
]]

local Info = {
    ProjectName = "REPLACEME",
    WebhookURL = "REPLACEME",
    UseOutputInstead = false,
}

---------------

export type Info = typeof(Info)

---------------

return Info]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXDBF7B885C40E41E98730B8916189832F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Messages</string>
							<string name="ScriptGuid">{56F11A3F-48BF-49DC-A25C-4DE5CA30D6A8}</string>
							<ProtectedString name="Source"><![CDATA[--[[
    NOTE:

    SAVE AND RESTART STUDIO TO APPLY CHANGES.
]]

--[[
    These are the special messages sent upon starting / ending / pausing a session.

    scroll down
    ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
]]

local Assets = require(script.Parent.Assets)
local Info = require(script.Parent.Info)

local Messages = {
    Start = {},
    SessionRecovered = {},
    Close = {},
    Pause = {},
    Resume = {},
    LineSeparators = {},
}

---------------

export type MessageList = {string}
export type Messages = typeof(Messages)

---------------

function Messages.add(to: MessageList, text: string)
    table.insert(to, text)
end

function Messages.get(from: MessageList): string?
    if #from < 1 then
        return nil
    end

    local randomMessage = math.random(1, #from)

    return from[randomMessage]
end

---------------

--[[
    ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ 
    ADD MORE MESSAGES HERE
    ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ 

    If you dont want special messages to be sent, dont add them.
        this applies to all the specific categories too
            dont want "Close" messages? remove all the `Messages.add(Messages.Close)` lines

    Example:
        Messages.add(Messages.Start, "hello world!")

        to add a message to the session start
]]

--[[
    SPECIAL TAGS
    spice up your messages with them

    ...

    SESSIONTIME
        time spent on the current session

    TOTALTIME
        total time spent on the project

    TODAYSDATE
        day, hour, minute, second right now

    SESSIONSTATE
        state of the session (paused or ongoing)

    ...
]]

Messages.add(Messages.Start, "Session Started! TODAYSDATE " .. Assets.Emojis.Rat)
Messages.add(Messages.Start, Info.ProjectName .. " Session Started... TODAYSDATE yay" .. Assets.Emojis.Angry)

Messages.add(Messages.SessionRecovered, "Session Recovered! state: SESSIONSTATE time rn: SESSIONTIME")
Messages.add(Messages.SessionRecovered, "im so glad you remembered to bring me back! SESSIONSTATE Session recovered. SESSIONTIME")

Messages.add(Messages.Close, "Session Closed! total time ever: TOTALTIME")
Messages.add(Messages.Close, "Session Closed unfortunately. total time ever: TOTALTIME")

Messages.add(Messages.Pause, "paused.")
Messages.add(Messages.Pause, "pausedddddd")

Messages.add(Messages.Resume, "resumed")
Messages.add(Messages.Resume, "resumeddddddddddd12313213")

Messages.add(Messages.LineSeparators, "----------------")

---------------

return Messages]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>